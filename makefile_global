
################################################################################
# You shouldn't need to configure anything further
# for your project below this line
################################################################################

# fancy colors cause we're fancy
CLEAR=\033[0m
BOLD=\033[1m
CYAN=\033[1;36m
RED=\033[1;31m
YELLOW=\033[1;33m
GREEN=\033[1;32m

# Hardware fallbacks in case the user didn't set them
HW_CFG?=REGION=US VIDEO=NTSC VRAM_SIZE=VRAM_64K

## MEGADEV SDK Paths
# library (ASM and C)
LIB_PATH:=$(MEGADEV_PATH)/lib

# build time tools
TOOLS_PATH:=$(MEGADEV_PATH)/tools

# linker scripts
CFG_PATH:=$(MEGADEV_PATH)/cfg

## Toolchain
# we assume all commands appear somewhere in $PATH
# if this is not the case, you will need to specify
# the full path of each command
M68K_PREFIX?=m68k-elf-

CC:=$(M68K_PREFIX)gcc
OBJCPY:=$(M68K_PREFIX)objcopy
NM:=$(M68K_PREFIX)nm
LD:=$(M68K_PREFIX)ld
AS:=$(M68K_PREFIX)as

Z80_AS:=sjasmplus

## Project Output
BUILD_PATH:=$(OUT_PATH)/$(SRC_PATH)

MMD_DEF:=$(wildcard $(SRC_PATH)/*.mmd.def)
SMD_DEF:=$(wildcard $(SRC_PATH)/*.smd.def)
BIN_DEF:=$(wildcard $(SRC_PATH)/*.bin.def)
MOD_DEF:=$(strip $(MMD_DEF) $(SMD_DEF) $(BIN_DEF))

# RMODS are "resident" modules, which will be built first
# this ensures they can be referenced as libraries in later modules
SRC:=$(if $(MOD_DEF),$(sort $(filter %.c %.s, $(shell cat $(MOD_DEF)))),)
#$(info SRC: $(SRC))
RMOD:=$(if $(MOD_DEF),$(sort $(filter-out ip.bin sp.bin, $(filter %.mmd %.smd %.bin, $(shell cat $(MOD_DEF))))),)
#$(info RMOD: $(RMOD))
MOD:=$(filter-out $(RMOD),$(basename $(notdir $(MOD_DEF))))
#$(info MOD: $(MOD))
OBJ:=$(addsuffix .o,$(SRC))
#$(info OBJ: $(OBJ))

OUT_RMOD:=$(addprefix $(DISC_PATH)/,$(RMOD))
#$(info OUT_RMOD: $(OUT_RMOD))
OUT_MOD:=$(addprefix $(DISC_PATH)/,$(MOD))
#$(info OUT_MOD: $(OUT_MOD))
OUT_OBJ:=$(addprefix $(BUILD_PATH)/,$(OBJ))
#$(info OUT_OBJ: $(OUT_OBJ))

# setup includes
INC:=-I$(SRC_PATH) -I$(LIB_PATH) -I$(RES_PATH) -I$(BUILD_PATH) 
# We have to manually pass the includes to the assembler
# Each entry here should match each entry in INC, with a prefix of "-Wa,"
AS_INC:=-Wa,-I$(SRC_PATH) -Wa,-I$(LIB_PATH) -Wa,-I$(RES_PATH) -Wa,-I$(BUILD_PATH)

# build flags
# Note: we include "-Wa,--register-prefix-optional" as a default C option
# because it is useful for inline asm. However, "-Wa,--bitwise-or" will
# cause issues with the GCC created asm, so we split that off and only use it
# with asm source files
CC_FLAGS:=-m68000 -imacros build_def.h $(OPT_FLAGS) $(addprefix -D, $(HW_CFG)) $(if $(DEBUG), -DDEBUG) -fno-builtin -fomit-frame-pointer -fno-gcse -Wall -Wextra -Wno-main -Wa,--register-prefix-optional
AS_FLAGS:=-Wa,--bitwise-or
LD_FLAGS:=-nostdlib

define msg_info
	@echo -e "${BOLD}${CYAN}$(1)${CLEAR}"
endef

define msg_warning
	@echo -e "${BOLD}${RED}$(1)${CLEAR}"
endef

# args: 1: input list, 2: output, 3: link script, 4: rmods
define link_module
	@$(eval mod_elf:= $(BUILD_PATH)/$(notdir $(2)).elf)
	$(call msg_info,Linking module $(notdir $(2)))
	@$(LD) $(LD_FLAGS) -z muldefs -T$(3) $(1) $(if $(4), $(foreach r,$(4),-R $(BUILD_PATH)/$(r).elf)) -o $(mod_elf)
	@$(NM) -n $(mod_elf) > $(BUILD_PATH)/$(basename $(notdir $(mod_elf))).sym
	@$(OBJCPY) -O binary $(mod_elf) $(2)
endef

default: init boot_sector objects modules iso

$(shell $(MEGADEV_PATH)/makedefs.sh $(SRC_PATH) > makefile_mdefs)
include makefile_mdefs

.PHONY: clean pristine boot_sector modules iso init

.SECONDARY:

vpath %.c $(SRC_PATH):$(LIB_PATH):$(LIB_PATH)/sub:$(LIB_PATH)/main
vpath %.h $(SRC_PATH):$(LIB_PATH):$(LIB_PATH)/sub:$(LIB_PATH)/main
vpath %.s $(SRC_PATH):$(LIB_PATH):$(LIB_PATH)/sub:$(LIB_PATH)/main
vpath %.mmd.def $(SRC_PATH)
vpath %.smd.def $(SRC_PATH)
vpath %.bin.def $(SRC_PATH)
vpath %.elf $(BUILD_PATH)
vpath %.o $(BUILD_PATH)

clean:
	$(call msg_warning,Removing all build artifacts)
	@rm -rf makefile_mdefs
	@rm -rf $(BUILD_PATH)/* $(OUT_RMOD) $(OUT_MOD)

pristine: clean
	$(call msg_warning,Removing ISO image and build paths)
	@rm -rf $(OUT_PATH)/$(PROJECT_NAME).iso
	@rm -rf $(BUILD_PATH) $(DISC_PATH)

boot_sector: $(BUILD_PATH)/boot.bin

objects: $(OUT_OBJ)

modules: objects $(OUT_RMOD) $(OUT_MOD)

iso: $(BUILD_PATH)/boot.bin
	$(call msg_info,Building ISO image $(PROJECT_NAME).iso)
	@mkisofs -quiet -iso-level 1 -G $< -pad -V "$(PROJECT_NAME)" -o $(OUT_PATH)/$(PROJECT_NAME).iso $(DISC_PATH)

init:
	@mkdir -p $(BUILD_PATH) $(DISC_PATH) $(SRC_PATH)

# create intermediary ip/sp ELFs in case we want to link against them as resident modules (RMODs)
$(BUILD_PATH)/ip.bin.elf: $(BUILD_PATH)/ip.s.o
	@$(LD) $(LD_FLAGS) -T$(CFG_PATH)/ip.ld -o$@ $<
	@$(NM) -n $@ > $(basename $@).sym

$(BUILD_PATH)/sp.bin.elf: $(BUILD_PATH)/sp_header.s.o $(BUILD_PATH)/sp.s.o
	@$(LD) $(LD_FLAGS) -T$(CFG_PATH)/sp.ld -o$@ $^
	@$(NM) -n $@ > $(basename $@).sym

$(BUILD_PATH)/boot.s.o: ip.bin.elf sp.bin.elf
	@$(OBJCPY) -O binary $(BUILD_PATH)/ip.bin.elf $(BUILD_PATH)/ip.bin
	@$(OBJCPY) -O binary $(BUILD_PATH)/sp.bin.elf $(BUILD_PATH)/sp.bin
	@$(CC) $(CC_FLAGS) $(AS_FLAGS) $(INC) $(AS_INC) -x assembler-with-cpp -c $(LIB_PATH)/boot.s -o$@

$(BUILD_PATH)/boot.bin: $(BUILD_PATH)/boot.s.o
	$(call msg_info,Generating boot sector...)
	@$(OBJCPY) -O binary $< $@

$(BUILD_PATH)/%.c.o: %.c
	$(call msg_info,Compiling source $(notdir $<))
	@$(CC) $(CC_FLAGS) $(INC) $(AS_INC) -c $< -o$@

$(BUILD_PATH)/%.s.o: %.s
	$(call msg_info,Compiling source $(notdir $<))
	@$(CC) $(CC_FLAGS) $(AS_FLAGS) $(INC) $(AS_INC) -x assembler-with-cpp -c $< -o$@
